\documentclass{amsart}
\usepackage{amsmath, amssymb}
%\usepackage{mathpartir}
\usepackage{listings}
\usepackage{fancyvrb}
\usepackage{color}
\usepackage{bussproofs}
\usepackage{pgf, tikz}
\usetikzlibrary{arrows, automata}
\usepackage{hyperref}

\fvset{%
  fontsize=\small,
  numbers=left
}

\makeatletter
\renewcommand\subsection{\@startsection{subsection}{2}%
  \z@{-.5\linespacing\@plus-.7\linespacing}{.5\linespacing}%
  {\normalfont\scshape}}
\renewcommand\subsubsection{\@startsection{subsubsection}{3}%
  \z@{.5\linespacing\@plus.7\linespacing}{-.5em}%
  {\normalfont\scshape}}
\makeatother

\setcounter{tocdepth}{3}
\makeatletter
\def\l@subsection{\@tocline{2}{0pt}{2.5pc}{5pc}{}}
%Make Chapter disapear in ToC
\renewcommand\tocchapter[3]{%
  \indentlabel{\@ifnotempty{#2}{\ignorespaces#2.\quad}}#3%
}
\newcommand\@dotsep{4.5}
\def\@tocline#1#2#3#4#5#6#7{\relax
  \ifnum #1>\c@tocdepth % then omit
  \else
    \par \addpenalty\@secpenalty\addvspace{#2}%
    \begingroup \hyphenpenalty\@M
    \@ifempty{#4}{%
      \@tempdima\csname r@tocindent\number#1\endcsname\relax
    }{%
      \@tempdima#4\relax
    }%
    \parindent\z@ \leftskip#3\relax \advance\leftskip\@tempdima\relax
    \rightskip\@pnumwidth plus1em \parfillskip-\@pnumwidth
    #5\leavevmode\hskip-\@tempdima{#6}\nobreak
    \leaders\hbox{$\m@th\mkern \@dotsep mu\hbox{.}\mkern \@dotsep mu$}\hfill
    \nobreak
    \hbox to\@pnumwidth{\@tocpagenum{#7}}\par
    \nobreak
    \endgroup
  \fi}

\title{Git Instruction Manual}
\author{Evan Bergeron\\
Sunny Gakhar\\
Nishad Gothoskar\\
Frederick Lee\\
Ziyang Wang
}


\begin{document}
\maketitle

\tableofcontents
\section*{Introduction}

This is a manual on how to set up Git on your computer and set up a basic Git workflow. The document covers installing and setting up Git and how to work with Git. The majority of this document is primarily intended for users who want to learn Git to use it in a fast-paced setting such as a hackathon, this document is also useful as a reference for experienced Git users who want to refer to some specifc concept or command which they need.

\section*{What is Git}

Git is a version control system designed to be used for working on small and large projects.

\subsection*{Motivation}
When you were in school and you had short homework assignments, you would just start them and finish them in a short span of time (not longer than a week). But when you move on to designing and working on bigger projects, there are multiple issues that come into play. Say you are participating in a hackathon and have finalized your idea and distribution of work among the teammates. How do you actually work on the project together. Having all of them work on one computer is not optimal. You might have each teammate work on his own piece independently, but how do you merge everyone's work? Moreover, what if two or more teammates work on the same file, but do different modifications unknown to the others? And what if someone wants to explore a different direction to work on, while keeping the original work intact? Enter Git.

\newpage

\section*{Installing Git}

\subsection*{Windows}
If you have Windows, one easy way of installing Git is from this website:

\url{https://git-scm.com/download/win}

Once you have downloaded the installation file, you can run it and proceed through the installation steps.

\subsection*{Mac}

Similar to Windows, one way of installing Git on is from this link

\url{https://git-scm.com/download/mac}

\subsection*{Linux}

If you're working on Linux, you can install Git using a basic package management tool that comes with your distribution.

For example, for ubuntu, you have

\verb|apt-get install git|

or for Arch Linux, you have

\verb|pacman -S git|

Here 
\newpage

\section*{Initializing Repository}

To make sure you have Git set up, type \verb|git| into your console and the following should show up.

\begin{verbatim}
usage: git [--version] [--help] [-C <path>] [-c name=value]
[--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
[-p | --paginate | --no-pager] [--no-replace-objects] [--bare]
[--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
<command> [<args>]

...

'git help -a' and 'git help -g' list available subcommands and some
concept guides. See 'git help <command>' or 'git help <concept>'
to read about a specific subcommand or concept.
\end{verbatim}

To start a new repository, type \verb|git init| into the console. It should output the following

\begin{verbatim}
Initialized empty Git repository in <path to current directory>/.git/
\end{verbatim}


\newpage

\section*{Adding files to version control}

\section*{Committing changes}

\section*{Reverting changes}

\section*{Branching}

\section*{Merging Branches}

\section*{Ignoring Files}

\section*{Rebasing}

\section*{Cherrypicking}

\section*{Collaboration with Github}

\section*{General workflows}

\subsection*{Easily Reordering Commits}

We’ve all been there. You pull from master, take several minutes to
clean up the various merge conflicts, and then are ready to push. You
pull one last time before pushing, and what do you know - someone has
pushed again in the last couple minutes.

Previously, my workflow for this situation would look something like
\begin{verbatim}
$ git checkout -b tmp
$ git checkout master
$ git reset --hard HEAD~
$ git cherry-pick tmp
\end{verbatim}

This works fine, but there’s a much easier way -- one that involves
very little typing. We can simply say
\[
  \texttt{git rebase -i HEAD~2}
\]
This will open an interactive git rebasing session (the \texttt{-i}
stands for interactive). The window will display something along the
lines of
\begin{verbatim}
pick 370e221 Commit one
pick c342396 Commit two
\end{verbatim}
In whichever text editor we’re in, we may simply reorder these lines
to reorder the commits. Much shorter!

\subsection*{Adding partial files}
I just used this, actually. Suppose you’ve changed a single file
\texttt{foo.c} in different sections, and each of these changes are
logically different. For instance, maybe you refactor some function
\texttt{foo}, while at the same time fixing a bug in function
\texttt{bar}. Rather than create a separate branch and manaully edit
the files, we can simply say
\[
  \texttt{git add -p foo.c}
\]
This will bring up an interactive prompt. It will automatically cycle
through all the different areas of the diff, asking you if you want to
stage each section. You may hit \texttt{y} or \texttt{n} for yes or
no.

Once you’re done adding the subset of changes you want to commit, you
can double-check you have the right changes staged by saying
\[
  \texttt{git diff --cached}
\]
Once you’re sure that you’re good to go, just commit your changes as
normal. You can repeat this process for the remaining changes. (Or
just do a normal \texttt{git add} at this point).

\subsection*{Git aliases}
Git aliases are a good way to save yourself a lot of typing. I
frequently want to see the git commit history, but don’t especially
care about the body of each commit. Here’s the command I’ve added to
my configuration:
\[
  \texttt{git config --global alias.l "log --oneline"}
\]
I can then just type “\texttt{git l}” to see a one line log of this
commit history. If there are several long commands you use frequently,
this can be a great way to save yourself some time.

\section*{Vim workflows}

At the time of writing, perhaps the most feature complete vim-git
plugin is Tim Pope’s “vim-fugitive.” Consequently, we will assume
usage of this plugin throughout the entire vim workflows tutorial.

\subsection*{Installing vim-fugitive}

There are a number of ways to install vim-fugitive. The one suggested
by Tim Pope is as follows:
\begin{verbatim}
$ cd ~/.vim/bundle
$ git clone git://github.com/tpope/vim-fugitive.git
$ vim -u NONE -c "helptags vim-fugitive/doc" -c q
\end{verbatim}
Vundle is a great plugin manager for vim -- if you use this, you may
simply add the line
\[
  \texttt{Plugin 'tpope/vim-fugitive}
\]
to your vimrc and run the \texttt{PluginInstall} command.

\subsection*{Easy git blame}
You’re browsing some file and discover a horrible bug written by one
of your coworkers. You’re about to storm over to someone’s desk and
verbally abuse them for producing incorrect code. Before you deliver
your diatribe, you need to know who to blame.

Before using \texttt{vim-fugitive}, you would have to exit vim,
manually type “\texttt{git blame <filename>},” and then search for the
relevant line in the output. Now, you can simply type
“\texttt{:Gblame}” in your vim prompt, and a vertical split will open
up right next to the line in question. You could even establish a
keybinding to do this for you! What was once several lines of typing
is now a single keystroke away! Your coworkers have never been so
scared\ldots

\section*{Emacs workflows}

Similarly to vim-fugitive for vim, “Magit” is (at the time of
writing), the most feature-complete git wrapper for emacs. We will
thus assume usage of this package.

\subsection*{Installing Magit}

\end{document}